import React, { useEffect } from 'react';

function ComponentShield(props) {
  var showForRole = props.showForRole,
      showIf = props.showIf,
      _props$fallback = props.fallback,
      fallback = _props$fallback === void 0 ? null : _props$fallback,
      RBAC = props.RBAC,
      userRole = props.userRole,
      children = props.children;
  if (RBAC) return React.createElement(React.Fragment, null, showForRole === userRole ? children : null);
  if (showIf) return React.createElement(React.Fragment, null, children);
  return React.createElement(React.Fragment, null, fallback);
} // function Debug() {
//   return (
//     <>
// <ComponentShield showIf={true}>
//   <p>Default</p>
// </ComponentShield>
//       <ComponentShield RBAC showForRole="" userRole="">
//         <p>RBAC</p>
//       </ComponentShield>
//     </>
//   )
// }

function verifyPath(routes, uri) {
  return routes == null ? void 0 : routes.some(function (route) {
    return route === uri;
  });
}
function getAccessRoute(RBAC, userRole, accessRoute) {
  if (typeof accessRoute !== 'undefined') return accessRoute;
  if (RBAC && userRole) return RBAC[userRole].accessRoute;
  return '/';
}

/**
 * ðŸ˜‰ The shield that every Next.js app needs
 *
 * @typeParam NextShieldProps - {@link NextShieldProps | see here}
 * @returns NextShield Component
 *
 * @example
 * ```tsx
 * import { Loading } from '@/components/routes/Loading'
 * import { useAuth } from '@/hooks/auth'
 *
 * export default function MyApp({ Component, pageProps }: AppProps) {
 *  const { isAuth, isLoading } = useAuth()
 *  const router = useRouter()
 *
 *  return (
 *    <NextShield
 *      isAuth={isAuth}
 *      isLoading={isLoading}
 *      router={router}
 *      privateRoutes={['/protected']}
 *      publicRoutes={['/']}
 *      hybridRoutes={['/products/[slug]']}
 *      LoadingComponent={<Loading />}
 *    >
 *      <Component {...pageProps} />
 *    </NextShield>
 *   )
 * }
 *
 * ```
 * @packageDocumentation
 */

function NextShield(_ref) {
  var isAuth = _ref.isAuth,
      isLoading = _ref.isLoading,
      _ref$router = _ref.router,
      pathname = _ref$router.pathname,
      replace = _ref$router.replace,
      loginRoute = _ref.loginRoute,
      accessRoute = _ref.accessRoute,
      privateRoutes = _ref.privateRoutes,
      publicRoutes = _ref.publicRoutes,
      hybridRoutes = _ref.hybridRoutes,
      LoadingComponent = _ref.LoadingComponent,
      RBAC = _ref.RBAC,
      userRole = _ref.userRole,
      children = _ref.children;
  var pathIsPrivate = verifyPath(privateRoutes, pathname);
  var pathIsPublic = verifyPath(publicRoutes, pathname);
  var pathIsHybrid = verifyPath(hybridRoutes, pathname);
  var pathIsAuthorized = RBAC && userRole && verifyPath(RBAC[userRole].grantedRoutes, pathname);
  var access = getAccessRoute(RBAC, userRole, accessRoute);
  useEffect(function () {
    if (!isAuth && !isLoading && pathIsPrivate) replace(loginRoute);
    if (isAuth && !isLoading && pathIsPublic) replace(access);
    if (isAuth && userRole && !isLoading && !pathIsHybrid && !pathIsAuthorized) replace(access);
  }, [replace, userRole, access, isAuth, isLoading, loginRoute, pathIsPrivate, pathIsPublic, pathIsHybrid, pathIsAuthorized]);
  if ((isLoading || !isAuth) && pathIsPrivate || (isLoading || isAuth) && pathIsPublic || (isLoading || userRole) && !pathIsAuthorized && !pathIsHybrid || isLoading && pathIsHybrid) return React.createElement(React.Fragment, null, LoadingComponent);
  return React.createElement(React.Fragment, null, children);
}

export { ComponentShield, NextShield };
//# sourceMappingURL=next-shield.esm.js.map
